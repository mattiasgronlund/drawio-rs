#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import re
from pathlib import Path
from xml.etree import ElementTree as ET


cell_id_RE = re.compile(r"^edge_(?P<id>[^_]+)__")


def extract_cell_id(drawio_path: Path) -> str | None:
    match = cell_id_RE.match(drawio_path.stem)
    return match.group("id") if match else None


def find_cell_group(root: ET.Element, cell_id: str) -> ET.Element | None:
    for elem in root.iter():
        if elem.tag.endswith("g") and elem.attrib.get("data-cell-id") == cell_id:
            return elem
    return None


def path_elements(group: ET.Element) -> list[ET.Element]:
    return [elem for elem in group.iter() if elem.tag.endswith("path")]


def collect_paths(svg_path: Path, cell_id: str) -> list[dict[str, str]]:
    try:
        tree = ET.parse(svg_path)
    except ET.ParseError:
        return []
    group = find_cell_group(tree.getroot(), cell_id)
    if group is None:
        return []
    return [dict(path.attrib) for path in path_elements(group)]


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Create per-path variants.csv files from SVG exports."
    )
    parser.add_argument(
        "variants_csv", type=Path, help="CSV generated by edge_style_sweep.py"
    )
    parser.add_argument(
        "--svg-dir",
        type=Path,
        default=Path("tmp/edge-style-sweep/svg"),
        help="Directory containing SVG exports",
    )
    parser.add_argument(
        "--out-dir",
        type=Path,
        default=Path("tmp/edge-style-sweep"),
        help="Directory for output CSV files",
    )
    args = parser.parse_args()

    with args.variants_csv.open("r", newline="") as csv_file:
        reader = csv.DictReader(csv_file)
        rows = list(reader)
        base_fields = list(reader.fieldnames or [])

    path_attrs_by_row: list[list[dict[str, str]]] = []
    max_paths = 0
    attr_names: set[str] = set()
    for row in rows:
        drawio_path = Path(row.get("file", ""))
        cell_id = row.get("cell_id") or row.get("edge_id") or extract_cell_id(drawio_path)
        svg_path = args.svg_dir / f"{drawio_path.stem}.svg"
        if not cell_id or not svg_path.exists():
            # print(f"{cell_id}: {svg_path.exists()}, {svg_path}")
            path_attrs_by_row.append([])
            continue
        paths = collect_paths(svg_path, cell_id)
        path_attrs_by_row.append(paths)
        max_paths = max(max_paths, len(paths))
        for attrs in paths:
            attr_names.update(attrs.keys())

    ordered_attrs = sorted(attr_names)
    out_dir = args.out_dir
    out_dir.mkdir(parents=True, exist_ok=True)

    for path_index in range(max_paths):
        fieldnames = base_fields + ordered_attrs
        out_path = out_dir / f"variants_path_{path_index}.csv"
        with out_path.open("w", newline="") as csv_file:
            writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
            writer.writeheader()
            for row, paths in zip(rows, path_attrs_by_row):
                attrs = paths[path_index] if path_index < len(paths) else {}
                out_row = dict(row)
                for name in ordered_attrs:
                    out_row[name] = attrs.get(name, "")
                writer.writerow(out_row)
        print(f"wrote {out_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
